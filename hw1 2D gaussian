'''
Evaluate the following function (a Gaussian in two dimensions, or, if you like fancy words, a multivariate normal distribution function --although this is missing a constant factor in the front):

f(ξ)=exp(−12(ξ−μ)TΣ−1(ξ−μ))
f(ξ)=exp⁡(−12(ξ−μ)TΣ−1(ξ−μ))
Where for a single point in the plane, ξ=(xi,yi)ξ=(xi,yi). That is a point with coordinates xixi and yiyi.

You will evaluate the Gaussian function for a grid generated by variables x and y specifying the xx and the yy coordinates of the grid points. For example, x={0,1}x={0,1} and y={0,1}y={0,1} would generate the following four points in the plane: (0,0),(0,1),(1,0),(1,1)(0,0),(0,1),(1,0),(1,1)
Store the evaluation result in the variable gaussian and plot the function as a pseudocolor plot in the plane.

INPUT:

x, a numpy array of shape (50,), containting xx coordinates of where the Gaussian is to be evaluated
y, a numpy array of shape (50,), containting yy coordinates of where the Gaussian is to be evaluated
covariance_mat, the matrix ΣΣ from above, a (2,2) numpy array
mu, the vector μμ from above, a (2,)-shaped numpy array
OUTPUT:

gaussian, a numpy array of shape (50, 50), containing values of the Gaussian on the grid of points given by x and y

A plot of gaussian, obtained with matplotlib.pyplot.imshow()
'''



import numpy as np
import matplotlib.pyplot as plt
import math

# initialize the array with 0
h=len(x);
w=len(y);
gaussian=np.zeros((h,w)) ;
# do co_mat_inverse and convert column arrays into row array for value extraction
mat_inverse=np.linalg.inv(covariance_mat);
xx=np.transpose(x);
yy=np.transpose(y);
mm=np.transpose(mu);
# find gaussian value base on coord
for i in range(0,h):
    for j in range(0,w):
        #first find the vector
        pos=np.zeros(2);
        pos[0]=xx[i]-mu[0];
        pos[1]=yy[j]-mu[1];
        #do matrix multiplication
        exp=pos@mat_inverse@np.transpose(pos);
        val=math.exp(-0.5*exp);
        #return and store the value
        gaussian[i][j]=val;
# show plot
plot=plt.imshow(gaussian);
